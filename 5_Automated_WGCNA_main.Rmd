# WGCNA Pipeline 
> **Description**: This pipeline automate WGCNA pipeline.
So What is WGCNA? Weighted Gene/Metabolite Co-expression Network Analysis (WGCNA/WMCNA)
WGCNA (for genes) and WMCNA (for metabolites) are network-based methods used to identify groups of co-expressed molecules, called modules, that may share common biological functions.   
The analysis starts by computing pairwise correlations (typically Pearson) between all features across samples. These correlations are then transformed into a weighted network using a soft-thresholding power, this help remove weak association- which ensures that the resulting network follows a scale-free topology, a common feature of biological systems.  
From the adjacency matrix, a topological overlap matrix (TOM) is calculated to measure how connected each pair of features is, considering both direct and shared connections. This leads to the identification of modules through hierarchical clustering and dynamic tree cutting, grouping together molecules with similar expression patterns.  
To relate modules to biological phenotypes, the module eigengenes (the first principal component of each module) are correlated with external traits, typically using Pearson correlation. When the phenotype is binary, it is encoded as 0 and 1. Modules that are significantly correlated with the phenotype of interest are then subjected to functional enrichment analysis to uncover associated pathways and biological functions.  
Finally, within these relevant modules, hub genes or metabolites—those with high intra-modular connectivity (i.e., high degree centrality)—are identified. These hubs are considered potential biomarker candidates or key regulatory features associated with the condition under study.
Output Files:  
**module_eigengenes.csv**:	Eigengenes (first principal component) for each module; used for trait correlation.  
**gene_module_assignment.csv**:	Module assignment of each gene/metabolite (e.g., blue, brown, etc.).  
**modules.csv**:	Lists of features grouped by module. Each column represents a module.  
**module_membership.csv**:	Correlation (kME) of each gene with its module eigengene (i.e., intramodular connectivity).  
**gene.trait.corr.csv**:	Correlation between each gene and the phenotype(s).  
**module_hubs.csv**:	Hub genes/metabolites within each module (high kME > hub_threshold).  
**CytoscapeInput-edges-.txt**:	Edge list for each module's network (TOM similarity > 0.02); ready for Cytoscape.  

**Project Initialization**
```{r ,warning = FALSE, message = FALSE}
#Sets the working directory and creates subfolders for organizing outputs.
mypath= "C:/Users/USER/Documents/Github/CRC_project/"
dir.create("output")
dir.create("plots")
dir.create("input")

```

```{r ,warning = FALSE, message = FALSE}
#Load libraries
library(tibble)
library(plyr)
library(dplyr)
library(tidyverse)
library(WGCNA)
allowWGCNAThreads()   

```

```{r ,warning = FALSE, message = FALSE}
#load data
#expression data
data= read.csv(paste0(mypath,"input/data_for_downstream.csv"))
data = data |>  column_to_rownames(colnames(data)[1]) 

group_dist= gsub("_.*", "", colnames(data))
group_levels= unique(group_dist)
#metadata
metadata= data.frame(sample= colnames(data) ,
                     condition= group_dist)
#metadata= read.csv("input/metadata_test.csv" )
metadata = metadata |>   column_to_rownames("sample")
metadata$condition= factor(metadata$condition, levels = group_levels)
design= model.matrix(~ 0+condition , metadata)
colnames(design)= gsub("condition","", colnames(design))
head(design)

```

## **WGCNA Pipeline**  
### **Choose appropriate power for soft-thresholding**
```{r ,warning = FALSE, message = FALSE}
# Elbow plot to choose the appropriate soft-thresholding power that ensures a scale-free (power-law) network topology.
plotelbow <- function(data) {

  # Choose a set of soft-thresholding powers (up to 20 is more informative)
  powers <- c(1:10)
  # Pick the soft threshold based on scale-free topology criterion
  sft <- pickSoftThreshold(t(data), powerVector = powers, verbose = 5)
  # Two plots side by side
  par(mfrow = c(1, 2)) 
  # Plot the Scale-Free Topology Fit Index (R^2)
  plot(sft$fitIndices[, 1], 
       -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
       xlab = "Soft Threshold (power)", 
       ylab = "Scale Free Topology Model Fit, signed R^2",
       type = "n",
       main = "Scale Independence")
  text(sft$fitIndices[, 1], 
       -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
       labels = powers, col = "red")
  abline(h = 0.80, col = "red", lty = 2)  # R^2 threshold line
  
  # Plot the Mean Connectivity
  plot(sft$fitIndices[, 1], sft$fitIndices[, 5], 
       xlab = "Soft Threshold (power)", 
       ylab = "Mean Connectivity", 
       type = "n",
       main = "Mean Connectivity")
  text(sft$fitIndices[, 1], sft$fitIndices[, 5], 
       labels = powers, col = "red")
  
  
}

#The chosen power should correspond to Signed R² (scale-free topology fit index) ≥ 0.9 &
#Mean connectivity is not too low (network should remain connected)
# Display the plot
plotelbow(data)
# save
png("plots/elbow_plot.png", width = 1700, height = 1000, res = 300)
plotelbow(data)
dev.off()


```

### **Set Main Parameters**
```{r ,warning = FALSE, message = FALSE}
#set your parameters
power= 4
minModuleSize = 20
metadata_binary= design
hub_threshold= 0.85
GS_threshold= 0.85 #(.2) default
#mapping_file= read.table("resources/Metabolites-HMDB.csv", header = T)



```

### **WGCNA Main Function**
```{r ,warning = FALSE, message = FALSE}
Run_WGCNA= function(data, metadata_binary, power,minModuleSize, hub_threshold ,GS_threshold,
                     mapping_file=NULL){
  
  power= power
  minModuleSize= minModuleSize
  data[]= lapply(data, as.numeric)
  datExpr= t(data) #so that samples become in row
  #This function checks data for missing entries, entries with weights below a threshold, and zero-variance genes, 
  goods <- goodSamplesGenes(datExpr, verbose = 3)
  datExpr= datExpr[goods$goodSamples== TRUE, goods$goodGenes == TRUE ]
  
  net = blockwiseModules(datExpr, corType = "pearson", maxBlockSize = 5000, 
                         networkType = "signed", power = power, minModuleSize =minModuleSize,
                         mergeCutHeight = 0.25, 
                         numericLabels = F, saveTOMs = TRUE, 
                         pamRespectsDendro = FALSE, saveTOMFileBase = "TOM")
  print("module detection is done")
  
  # A data frame with module eigengenes 
  module_eigengenes <- net$MEs
  write.csv(module_eigengenes, "output/module_eigengenes.csv")
  names(module_eigengenes)= gsub("ME", "", names(module_eigengenes) )
  print("module_eigengenes file is saved")
  
  #gene module assignment
  module.gene.assign= net$colors #vector of colors that assign each gene to its corresponding module
  write.csv(module.gene.assign, "output/gene_module_assignment.csv")
  print("gene_module_assignment file is saved")
  
  #Extract proteins for each modules
  module_names= names(module_eigengenes)
  module_lists= list()
  
  for (i in module_names){
    module_lists[[i]]=  module.gene.assign[module.gene.assign== i] |>  names()
  }
  
  df <- ldply(module_lists, rbind) |>  t()
  df[is.na(df)] <- ""
  df= as.data.frame(df)
  names(df) = df[1,] |>  as.vector()
  modules= df[-1,]
  write.csv(modules, paste0("output/", "modules.csv"), row.names = FALSE)
  print("modules file is saved!")
  
  
  #calculate gene significance (a measure that show to what degree the gene is correlated with phenotype) 
  nSamples <- nrow(datExpr)
  nGenes <- ncol(datExpr)
  gene.signf.corr <- cor(datExpr, metadata_binary, use = 'p')
  gene.signf.corr.pvals <- corPvalueStudent(gene.signf.corr, nSamples)
  write.csv(gene.signf.corr, "output/gene.trait.corr.csv")
  gene.signf.corr= gene.signf.corr  |>  as.data.frame()
  #Module membership (reflects intra-modular connectivity)
  # calculate the module membership values node i. The module membership kME(q) specifies how close node i is to module q. 
  #KME (module membership) defined as correlation between gene expression profile and the module eigengene of certain module 
  # if MMblue(i) is close to 1 or -1, it is highly connected to the blue module genes.
  # The sign of module membership encodes whether the gene has a positive or a negative relationship with the module eigengene. 
  datKME = signedKME(datExpr, module_eigengenes)
  write.csv(datKME, "output/module_membership.csv")
  
  
  #extract hub genes
  #Extract hubs for each modules
  module_names= names(module_eigengenes)
  hub_lists <- vector("list", length(module_names))
  names(hub_lists)= names(module_eigengenes)
  threshold= hub_threshold
  
  for(j in 1:length(module_names)){
    hub_mod= row.names(datKME)[datKME[,j] > threshold]
    hub_lists[[j]]= intersect(unlist(modules[j]),  hub_mod)
  }
  
  df= ldply(hub_lists, rbind) |>  t() 
  df[is.na(df)] <- ""
  df= as.data.frame(df)
  names(df) = paste0(unlist(df[1,]), "_hub") 
  hubs= df[-1,]
  write.csv(hubs, paste0("output/", "module_hubs.csv"), row.names = FALSE)
  print("hubs file is saved!")
  
  #Extract hubs correlated with phenotype
  hub_pheno <- vector("list", length= ncol(gene.signf.corr))
  names(hub_pheno)= names(gene.signf.corr)
  GS_threshold= GS_threshold
  
  for(j in 1:ncol(gene.signf.corr)){
    
    all_hubs= hub_lists |>  unlist() 
    all_hubs= all_hubs[all_hubs !="" & !is.na(all_hubs)]
    pheno_h= row.names(gene.signf.corr)[gene.signf.corr[,j] > GS_threshold]
    pheno_h= pheno_h[pheno_h %in% all_hubs]
    hub_pheno[[j]] = pheno_h
  }
  df= ldply(hub_pheno, rbind) |>  t() 
  df[is.na(df)] <- ""
  df= as.data.frame(df)
  names(df) = paste0(unlist(df[1,]), "_hub") 
  hubs= df[-1,]
  #write.csv(hubs, paste0("output/", "phenotype_cor_hubs.csv"), row.names = FALSE)
  #print("hubs_pheno file is saved!")
  

  #export networks for cytoscape
  module_names= names(module_eigengenes)
  for( i in   module_names) {
    datexpr_mod = datExpr[,module.gene.assign == i]
    TOM_mod = TOMsimilarityFromExpr(datexpr_mod, power = power, networkType = "signed", TOMType="signed Nowick");
    genes = colnames(datexpr_mod)
    dimnames(TOM_mod) = list(genes, genes)
    # nTop = 30;
    # IMConn = softConnectivity(datExpr[, probes]);
    # top = (rank(-IMConn) <= nTop)
    cyt = exportNetworkToCytoscape(TOM_mod,
                                   edgeFile = paste("output/CytoscapeInput-edges-.02tom", paste(i, collapse="-"), ".txt", sep=""),
                                   #nodeFile = paste("output/CytoscapeInput-nodes-", paste(i, collapse="-"), ".txt", sep=""),
                                   weighted = TRUE,
                                   threshold = 0.02, #threshold for including edges in the output, Default is 0.02
                                   nodeNames = genes,
                                   altNodeNames = genes);
  }
  print("networks exported!")
  print("ALL iS DONE!")
  return(net)
  
}

```
### **Run WGCNA**
```{r ,warning = FALSE, message = FALSE}
res= Run_WGCNA(data, metadata_binary=metadata_binary, power=power, minModuleSize= minModuleSize,
               hub_threshold= hub_threshold, GS_threshold=GS_threshold, mapping_file=NULL)


```

